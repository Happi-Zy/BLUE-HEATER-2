-- ULTRA BYPASS KILL AURA - Anti-Cheat Evasion System
-- Bypasses: Metatable hooks, Function hooks, Remote monitoring
-- Uses: Raw metatable access, Debug libraries, Multiple detection evasion

-- Kapao Hub UI with Kill Aura Integration
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- Services
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local UserInputService = game:GetService("UserInputService")

-- Wait for game to load
if not game:IsLoaded() then
    game.Loaded:Wait()
end

local LP = Players.LocalPlayer

-- Create Logo in top-left corner
spawn(function()
    wait(0.5)
    local screenGui = Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("ScreenGui") or CoreGui:FindFirstChildOfClass("ScreenGui")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    
    if screenGui then
        -- Logo Frame (Make it a button)
        local logoButton = Instance.new("TextButton")
        logoButton.Name = "KapaoLogo"
        logoButton.Size = UDim2.new(0, 160, 0, 160)
        logoButton.Position = UDim2.new(0, 10, 0, 10)
        logoButton.BackgroundTransparency = 1
        logoButton.Text = ""
        logoButton.Parent = screenGui
        
        -- Logo Image
        local logoImage = Instance.new("ImageLabel")
        logoImage.Name = "Logo"
        logoImage.Size = UDim2.new(1, 0, 1, 0)
        logoImage.Position = UDim2.new(0, 0, 0, 0)
        logoImage.BackgroundTransparency = 1
        logoImage.Image = "rbxassetid://129672522731097"
        logoImage.ScaleType = Enum.ScaleType.Fit
        logoImage.Parent = logoButton
        
        -- Add shadow/glow effect
        local logoGlow = Instance.new("ImageLabel")
        logoGlow.Name = "Glow"
        logoGlow.Size = UDim2.new(1.2, 0, 1.2, 0)
        logoGlow.Position = UDim2.new(-0.1, 0, -0.1, 0)
        logoGlow.BackgroundTransparency = 1
        logoGlow.Image = "rbxassetid://129672522731097"
        logoGlow.ImageTransparency = 0.7
        logoGlow.ScaleType = Enum.ScaleType.Fit
        logoGlow.ZIndex = 0
        logoGlow.Parent = logoButton
        
        -- Drag support for logo
        local dragging = false
        local dragStart
        local startPos

        local function clampToScreen(pos)
            local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)
            local x = math.clamp(pos.X, 0, vp.X - logoButton.AbsoluteSize.X)
            local y = math.clamp(pos.Y, 0, vp.Y - logoButton.AbsoluteSize.Y)
            return UDim2.fromOffset(x, y)
        end

        logoButton.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = logoButton.AbsolutePosition
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)

        UserInputService.InputChanged:Connect(function(input)
            if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local delta = input.Position - dragStart
                local newPos = Vector2.new(startPos.X + delta.X, startPos.Y + delta.Y)
                logoButton.Position = clampToScreen(newPos)
            end
        end)

        -- Enhanced breathing animation for logo
        local breatheTween = TweenService:Create(
            logoImage,
            TweenInfo.new(2.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            {Size = UDim2.new(1.08, 0, 1.08, 0), Position = UDim2.new(-0.04, 0, -0.04, 0)}
        )
        breatheTween:Play()
        
        -- Glow pulse animation
        local glowPulse = TweenService:Create(
            logoGlow,
            TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            {ImageTransparency = 0.5}
        )
        glowPulse:Play()
        
        -- Logo click to send Left Ctrl key (toggle UI)
        logoButton.MouseButton1Click:Connect(function()
            -- Send Left Ctrl key to toggle UI
            if VirtualInputManager then
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
                wait(0.05)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
            else
                -- Fallback method
                game:GetService("VirtualUser"):SetKeyDown(Enum.KeyCode.LeftControl)
                wait(0.05)
                game:GetService("VirtualUser"):SetKeyUp(Enum.KeyCode.LeftControl)
            end
            
            -- Enhanced click animation (like original)
            spawn(function()
                -- First: shrink with bounce
                local clickTween = TweenService:Create(
                    logoImage,
                    TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.In),
                    {Size = UDim2.new(0.8, 0, 0.8, 0), Position = UDim2.new(0.1, 0, 0.1, 0)}
                )
                clickTween:Play()
                clickTween.Completed:Wait()
                
                -- Second: expand back with bounce
                local releaseTween = TweenService:Create(
                    logoImage,
                    TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
                    {Size = UDim2.new(1.1, 0, 1.1, 0), Position = UDim2.new(-0.05, 0, -0.05, 0)}
                )
                releaseTween:Play()
                releaseTween.Completed:Wait()
                
                -- Third: settle back to normal
                local settleTween = TweenService:Create(
                    logoImage,
                    TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                    {Size = UDim2.new(1, 0, 1, 0), Position = UDim2.new(0, 0, 0, 0)}
                )
                settleTween:Play()
            end)
        end)
        
        -- Enhanced hover effects for logo
        logoButton.MouseEnter:Connect(function()
            -- Glow effect
            TweenService:Create(
                logoGlow,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {ImageTransparency = 0.3, Size = UDim2.new(1.3, 0, 1.3, 0), Position = UDim2.new(-0.15, 0, -0.15, 0)}
            ):Play()
            
            -- Logo slight scale up
            TweenService:Create(
                logoImage,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {Size = UDim2.new(1.05, 0, 1.05, 0), Position = UDim2.new(-0.025, 0, -0.025, 0)}
            ):Play()
        end)
        
        logoButton.MouseLeave:Connect(function()
            -- Restore glow
            TweenService:Create(
                logoGlow,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {ImageTransparency = 0.7, Size = UDim2.new(1.2, 0, 1.2, 0), Position = UDim2.new(-0.1, 0, -0.1, 0)}
            ):Play()
            
            -- Restore logo size
            TweenService:Create(
                logoImage,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {Size = UDim2.new(1, 0, 1, 0), Position = UDim2.new(0, 0, 0, 0)}
            ):Play()
        end)
    end
end)

-- Initialize Kill Aura Config
getgenv().KapaoConfig = getgenv().KapaoConfig or {
    KillAura_Enabled = false,
    KillAura_Range = 15,
    KillAura_MaxTargets = 2,
    KillAura_RandomDelay = true,
}

-- Create Window
local Window = Fluent:CreateWindow({
    Title = "Kapao Hub " .. Fluent.Version,
    SubTitle = "Happy Burnout Syndrome ;w;",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})

-- Create Tabs
local Tabs = {
    Combat = Window:AddTab({ Title = "‚öîÔ∏è Combat", Icon = "" }),
    Settings = Window:AddTab({ Title = "‚öôÔ∏è Settings", Icon = "" })
}

local Options = Fluent.Options

-- Advanced Configuration
local Config = {
    Enabled = true,
    Range = 10,  -- Safe range for close combat
    MaxTargets = 5,  -- Attack multiple targets
    AttackDelay = 0.25,  -- Locked at minimum 0.25 seconds (4 attacks per second max)
    RandomDelay = false,  -- Disable random delay for consistency
    MinRandomDelay = 0.25,  -- Minimum delay locked at 0.25
    MaxRandomDelay = 0.25,  -- Maximum delay locked at 0.25
    DebugMode = true,  -- Enable debug for new teleport system
    ManualSimulation = true,  -- Simulate manual clicking
    
    -- Teleport Settings (Simplified)
    TeleportToTargets = false,  -- Disable teleporting
    
    -- Rate Limit Bypass Settings
    UseMultipleRemotes = true,  -- Try different remotes
    BypassRateLimit = true,     -- Enable rate limit bypass techniques
    SpoofTimestamp = true,      -- Spoof attack timestamps
    
    -- Disable Rate Limiting for max speed
    MaxConsecutiveAttacks = 999,  -- Effectively unlimited
    BreakDuration = 0.1,  -- Minimal break
    CooldownDetection = false,  -- Disable cooldown detection

    -- Anti-Cheat Bypass Settings
    UseRawMetatable = true,    -- Use getrawmetatable to bypass hooks
    UseDebugLibrary = false,   -- Use debug library (risky)
    SpoofCallStack = true,     -- Spoof call stack
    RandomizeBytes = true,     -- Randomize byte pattern
    UseMultipleRemotes = true, -- Try multiple remote events
    AntiDetection = true,      -- Anti-detection measures

    -- Known Bytes Patterns (from your decompiled code)
    BytesPatterns = {
        {"\xCC", "\xD6", "\xB1", "\xFB"}, -- Original
        {"\xDD", "\xE7", "\xC2", "\x0C"}, -- Variant 1
        {"\xBB", "\xD5", "\xA0", "\xEA"}, -- Variant 2
    },

    -- Remote Event Names to Try
    PossibleRemotes = {
        "Event",
        "CombatEvent",
        "AttackEvent",
        "RemoteEvent",
        "FireServer"
    }
}

-- Kill Aura System
local KillAura = {}
KillAura.Enabled = false
KillAura.LastAttack = 0
KillAura.Connection = nil
KillAura.TargetList = {}
KillAura.HookBypassed = false
KillAura.RPCKey = nil

-- Rate Limiting Detection
KillAura.ConsecutiveAttacks = 0
KillAura.LastBreak = 0
KillAura.InBreak = false

-- Removed Teleport & Hover System

-- Enhanced Anti-Cheat Detection & Advanced Bypass
function KillAura:DetectAntiCheat()
    local suspiciousFunctions = {
        "hookfunction",
        "hookmetamethod", 
        "getrawmetatable",
        "debug.getinfo",
        "debug.getstack"
    }

    for _, funcName in pairs(suspiciousFunctions) do
        if _G[funcName] then
            return true
        end
    end

    -- Check for metatable hooks
    local mt = getrawmetatable(game)
    if mt and mt.__namecall then
        return true
    end

    return false
end

-- Advanced Performance Bypass System
function KillAura:BypassPerformanceChecks()
    local success = pcall(function()
        -- Bypass reputation system (from dumped code)
        local profiles = game.ReplicatedStorage:FindFirstChild("Profiles")
        if profiles then
            local playerProfile = profiles:FindFirstChild(LP.Name)
            if playerProfile then
                -- Spoof clean reputation
                local events = playerProfile:FindFirstChild("Events")
                if events then
                    -- Clear suspicious events
                    for _, event in pairs(events:GetChildren()) do
                        if event:IsA("IntValue") or event:IsA("NumberValue") then
                            event.Value = 0
                        end
                    end
                end
            end
        end
        
        -- Bypass camera detection
        local camera = workspace.CurrentCamera
        if camera.CameraType == Enum.CameraType.Scriptable then
            camera.CameraType = Enum.CameraType.Custom
        end
        
        -- Hide health vignettes
        local playerGui = LP:FindFirstChild("PlayerGui")
        if playerGui then
            for _, gui in pairs(playerGui:GetChildren()) do
                if gui.Name:find("Vignette") then
                    local bkg = gui:FindFirstChild("Bkg")
                    if bkg then
                        bkg.ImageTransparency = 1
                        bkg.Visible = false
                    end
                end
            end
        end
        
        -- Reduce hit effects
        local hitEffects = workspace:FindFirstChild("HitEffects")
        if hitEffects then
            for _, effect in pairs(hitEffects:GetChildren()) do
                if effect:IsA("ParticleEmitter") then
                    effect.Rate = math.min(effect.Rate, 2)
                    effect.Enabled = false
                end
            end
        end
        
    end)
    return success
end

-- Combat Cooldown Bypass (from dumped data)
function KillAura:BypassCombatCooldowns()
    local success = pcall(function()
        -- Spoof combat style to fastest (Dagger = 0.714s cooldown)
        -- But use SwordShield packets to avoid suspicion
        _G.CalculateCombatStyle = function()
            return "Dagger" -- Fastest cooldown internally
        end
        
        -- Override cooldown calculation
        _G.CalculateCombatCooldown = function()
            return 0.1 -- Ultra fast cooldown
        end
        
    end)
    return success
end

-- Advanced False Remote Bypass System
function KillAura:BypassFalseRemote()
    local success = pcall(function()
        -- Hook and block incoming false remotes
        local mt = getrawmetatable(game)
        if mt and mt.__namecall then
            local originalNamecall = mt.__namecall
            
            mt.__namecall = function(self, ...)
                local method = getnamecallmethod()
                local args = {...}
                
                -- Block false remote attacks targeting us
                if method == "FireServer" and args[1] == "Combat" then
                    local combatData = args[3]
                    if combatData and combatData[1] == "Attack" then
                        local target = combatData[2]
                        -- If target is our character, block it
                        if target == LP.Character then
                            return -- Block the false remote
                        end
                    end
                end
                
                return originalNamecall(self, ...)
            end
        end
        
        -- Additional protection: Monitor health changes
        local char = LP.Character
        if char then
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid and not self.HealthConnection then
                self.HealthConnection = humanoid.HealthChanged:Connect(function(health)
                    -- If health drops suddenly (false remote damage), restore it
                    if health < humanoid.MaxHealth * 0.9 then
                        task.wait(0.1)
                        humanoid.Health = humanoid.MaxHealth
                    end
                end)
                
            end
        end
    end)
    return success
end

-- Minimal Detection System (We have protection now!)
function KillAura:PreventFalseRemote()
    local success = pcall(function()
        -- Minimal pauses since we have false remote protection
        self.AttackCount = (self.AttackCount or 0) + 1
        
        -- Only very occasional pauses for pattern breaking
        if self.AttackCount % 50 == 0 then
            task.wait(math.random(100, 200) / 1000) -- 0.1-0.2s minimal pause
        end
        
        -- Reset counter to avoid overflow
        if self.AttackCount > 200 then
            self.AttackCount = 0
        end
    end)
    return success
end

-- Network Traffic Spoofing (Enhanced)
function KillAura:SpoofNetworkTraffic()
    local success = pcall(function()
        -- Send less frequent fake packets to avoid detection
        self.LastSpoofTime = self.LastSpoofTime or 0
        local now = tick()
        
        if now - self.LastSpoofTime > 8 then -- Every 8 seconds (less frequent)
            -- Send fake "movement" packets instead of idle
            local remote = self:GetRemote()
            if remote then
                pcall(function()
                    -- Simulate movement packet
                    remote:FireServer("Move", {
                        Position = Vector3.new(
                            math.random(-100, 100),
                            math.random(-10, 10), 
                            math.random(-100, 100)
                        ),
                        Timestamp = tick()
                    })
                end)
            end
            self.LastSpoofTime = now
        end
        
    end)
    return success
end

-- Bypass Metatable Hooks
function KillAura:BypassMetatableHooks()
    if not Config.UseRawMetatable then return end

    local success, result = pcall(function()
        local rawMT = getrawmetatable(game)
        if rawMT and rawMT.__namecall then
            -- Create a bypass function
            local originalNamecall = rawMT.__namecall

            local function bypassNamecall(self, ...)
                local method = getnamecallmethod()

                -- Check if this is our target remote
                if method == "FireServer" and typeof(self) == "Instance" then
                    local args = {...}
                    if args[1] == "Combat" then
                        KillAura.HookBypassed = true
                        return originalNamecall(self, ...)
                    end
                end

                return originalNamecall(self, ...)
            end

            -- Replace the hook
            rawMT.__namecall = bypassNamecall
            return true
        end
        return false
    end)

    return success and result
end

-- Find Remote Events
function KillAura:FindRemoteEvents()
    local remotes = {}

    -- Method 1: Scan ReplicatedStorage
    local function scanContainer(container, path)
        if not container then return end

        for _, child in pairs(container:GetChildren()) do
            if child:IsA("RemoteEvent") or child:IsA("UnreliableRemoteEvent") then
                table.insert(remotes, {
                    remote = child,
                    path = path .. "." .. child.Name,
                    score = 0
                })
            end

            if child:IsA("Folder") then
                scanContainer(child, path .. "." .. child.Name)
            end
        end
    end

    scanContainer(ReplicatedStorage, "ReplicatedStorage")

    -- Method 2: Scan all services
    for _, service in pairs({"Workspace", "Players", "Lighting", "StarterGui"}) do
        local container = game:GetService(service)
        scanContainer(container, service)
    end

    -- Method 3: Try to find by name patterns
    local namePatterns = {
        "Event", "Combat", "Attack", "Remote", "Server", "Fire", "Hit", "Damage"
    }

    for _, pattern in pairs(namePatterns) do
        for _, service in pairs({"ReplicatedStorage", "Workspace"}) do
            local container = game:GetService(service)
            if container then
                local found = container:FindFirstChild(pattern)
                if found and (found:IsA("RemoteEvent") or found:IsA("UnreliableRemoteEvent")) then
                    table.insert(remotes, {
                        remote = found,
                        path = service .. "." .. pattern,
                        score = 20
                    })
                end
            end
        end
    end

    -- Score remotes based on suspicious names
    for _, remoteInfo in pairs(remotes) do
        local name = remoteInfo.remote.Name:lower()
        if name:find("combat") or name:find("attack") or name:find("event") then
            remoteInfo.score = remoteInfo.score + 10
        end
        if name:find("server") or name:find("remote") then
            remoteInfo.score = remoteInfo.score + 5
        end
        if name:find("fire") or name:find("hit") then
            remoteInfo.score = remoteInfo.score + 8
        end
    end

    -- Sort by score
    table.sort(remotes, function(a, b)
        return a.score > b.score
    end)

    return remotes
end

    -- Skip RPC Key completely (use only tested method)
function KillAura:GetRPCKey()
    -- Always return nil to force using bytes method
    return nil
end

-- Get Current Remote
function KillAura:GetRemote()
    local event = ReplicatedStorage:FindFirstChild("Event")
    if event then
        return event
    else
        return nil
    end
end

-- Generate Bytes Pattern
function KillAura:GenerateBytes()
    if not Config.RandomizeBytes then
        return Config.BytesPatterns[1]
    end

    -- Create a variant of the bytes
    local baseBytes = Config.BytesPatterns[1]
    local variant = {}

    for i, byte in pairs(baseBytes) do
        -- Slight modification to bytes
        local byteValue = string.byte(byte)
        local modified = byteValue + math.random(-5, 5)
        modified = math.max(0, math.min(255, modified))
        variant[i] = string.char(modified)
    end

    return variant
end

-- Get Player Data (bypass anti-cheat)
function KillAura:GetPlayerData()
    local char = LP.Character
    if not char then return nil end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    return char, hrp
end

-- Validate Target (improved with better checks)
function KillAura:IsValidTarget(mob, playerPos)
    if not mob or not mob.Parent then
        return false
    end
    if not mob:IsA("Model") then
        return false
    end

    -- Check if it's in Mobs folder
    if mob.Parent.Name ~= "Mobs" then
        return false
    end

    -- Check if mob has required components
    local entity = mob:FindFirstChild("Entity")
    if not entity then
        return false
    end

    -- Check HumanoidRootPart
    local hrp = mob:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return false
    end

    -- Check if mob is frozen
    if CollectionService:HasTag(mob, "Frozen") then
        return false
    end

    -- Check Health (most important check)
    local health = entity:FindFirstChild("Health")
    if not health then
        return false
    end
    if health.Value <= 0 then
        return false
    end

    -- Check if mob is immortal
    if entity:FindFirstChild("Immortal") then
        return false
    end

    -- Distance check (silent)
    local distance = (playerPos - hrp.Position).Magnitude
    if distance > Config.Range then
        return false
    end

    -- Anti-detection checks
    if mob:FindFirstChild("ForceField") then
        return false
    end

        -- Valid target found
    return true, distance
end

-- Get Valid Targets (optimized for speed)
function KillAura:GetValidTargets()
    local char, hrp = self:GetPlayerData()
    if not char or not hrp then
        return {}
    end

    local playerPos = hrp.Position
    local mobsFolder = workspace:FindFirstChild("Mobs")
    if not mobsFolder then
        return {}
    end

    local validTargets = {}

    for _, mob in mobsFolder:GetChildren() do
        local isValid, distance = self:IsValidTarget(mob, playerPos)
        if isValid then
            table.insert(validTargets, {
                mob = mob,
                distance = distance
            })
        end
    end

    table.sort(validTargets, function(a, b)
        return a.distance < b.distance
    end)

    return validTargets
end

-- Select Targets
function KillAura:SelectTargets(validTargets)
    if #validTargets == 0 then return {} end

    local selectedTargets = {}
    local maxTargets = math.min(Config.MaxTargets, #validTargets)

    for i = 1, maxTargets do
        table.insert(selectedTargets, validTargets[i].mob)
    end

    return selectedTargets
end

-- Removed TweenToTarget function

-- Removed FollowCurrentTarget function

-- Removed HuntClosestTarget function

-- Execute Attack
function KillAura:ExecuteAttack(remote, targets)
    local success, errorMsg = pcall(function()
        for i, target in pairs(targets) do
            remote:FireServer(
                "Combat",
                {
                    "\xCC",
                    "\xD6",
                    "\xB1",
                    "\xFB"
                },
                {
                    "Attack",
                    target,
                    nil,
                    "2"
                }
            )
        end
    end)
    
    return success
end

-- Main Attack Function
function KillAura:Attack()
    local validTargets = self:GetValidTargets()
    if #validTargets == 0 then
        self.CurrentTarget = nil
        return
    end

    -- Removed hunt and follow system
    
    -- Attack targets in range
    local selectedTargets = self:SelectTargets(validTargets)
    if #selectedTargets == 0 then return end

    local remote = self:GetRemote()
    if not remote then return end

    -- Execute attack
    self:ExecuteAttack(remote, selectedTargets)
end

-- Ultra High Performance Update Loop
function KillAura:Update()
    if not self.Enabled then
        return
    end

    local currentTime = tick()
    local timeSinceLastAttack = currentTime - self.LastAttack
    
    -- Safe delay with slight randomization
    local actualDelay = 0.25 -- Standard 4 attacks per second
    if Config.RandomDelay then
        actualDelay = math.random(250, 270) / 1000 -- 0.25-0.27s random
    end

    if timeSinceLastAttack < actualDelay then
        return
    end

    -- Execute performance bypasses periodically
    if math.random(1, 300) == 1 then -- Every ~5 seconds at 60fps
        self:BypassPerformanceChecks()
        self:SpoofNetworkTraffic()
    end

    -- Quick target check
    local validTargets = self:GetValidTargets()
    if #validTargets == 0 then
        return
    end

    -- Execute anti-detection measures before attacking
    self:PreventFalseRemote()

    -- Attack targets in range
    local selectedTargets = self:SelectTargets(validTargets)
    if #selectedTargets == 0 then return end

    local remote = self:GetRemote()
    if not remote then return end

    -- Execute attack
    self:ExecuteAttack(remote, selectedTargets)
    self.LastAttack = currentTime
end


-- Start System
function KillAura:Start()
    if self.Enabled then
        return
    end


    -- Execute all advanced bypasses (maximum performance mode)
    self:BypassMetatableHooks()
    self:BypassPerformanceChecks()
    self:BypassCombatCooldowns() -- Re-enable for maximum speed
    self:BypassFalseRemote() -- False remote protection active
    self:SpoofNetworkTraffic()
    
    self.Enabled = true
    self.LastAttack = tick()

    -- Ultra high frequency execution (every frame for maximum performance)
    self.Connection = RunService.Heartbeat:Connect(function()
        if math.random(1, 2) == 1 then -- 50% chance each frame = ~30fps execution
            pcall(function()
                self:Update()
            end)
        end
    end)
    
end

-- Stop System
function KillAura:Stop()
    if not self.Enabled then return end

    self.Enabled = false
    
    -- Clear states (simplified)
    
    if self.Connection then
        self.Connection:Disconnect()
        self.Connection = nil
    end
end

-- Toggle System
function KillAura:Toggle()
    if self.Enabled then
        self:Stop()
    else
        self:Start()
    end
end

-- Combat Tab UI Elements (Kapao Hub Style)
do
    -- Header with Logo mention
    Tabs.Combat:AddParagraph({
        Title = "üéÆ Kapao Hub Combat Settings",
        Content = "Kill Aura with predictive aim"
    })

    -- Main Kill Aura Section
    local CombatSection = Tabs.Combat:AddSection("Kill Aura Settings")

    -- Kill Aura Toggle
    local KillAuraToggle = Tabs.Combat:AddToggle("KillAuraEnabled", {
        Title = "‚öîÔ∏è Kill Aura",
        Description = "Auto-target enemies",
        Default = false
    })

    KillAuraToggle:OnChanged(function()
        getgenv().KapaoConfig.KillAura_Enabled = Options.KillAuraEnabled.Value
        if Options.KillAuraEnabled.Value then
            KillAura:Start()
        else
            KillAura:Stop()
        end
    end)

    -- Range Slider
    local RangeSlider = Tabs.Combat:AddSlider("KillAuraRange", {
        Title = "üìè Attack Range",
        Description = "Max range",
        Default = 10,
        Min = 5,
        Max = 15,
        Rounding = 0,
        Callback = function(Value)
            getgenv().KapaoConfig.KillAura_Range = Value
            Config.Range = Value
        end
    })

    -- Max Targets Slider
    local MaxTargetsSlider = Tabs.Combat:AddSlider("MaxTargets", {
        Title = "üéØ Max Targets",
        Description = "Targets",
        Default = 5,
        Min = 1,
        Max = 20,
        Rounding = 0,
        Callback = function(Value)
            getgenv().KapaoConfig.KillAura_MaxTargets = Value
            Config.MaxTargets = Value
        end
    })

    -- Advanced Settings Section
    local AdvancedSection = Tabs.Combat:AddSection("Advanced Settings")

    -- Random Delay Toggle
    local RandomDelayToggle = Tabs.Combat:AddToggle("RandomDelay", {
        Title = "üé≤ Random Delay",
        Description = "Random timing",
        Default = true
    })

    RandomDelayToggle:OnChanged(function()
        getgenv().KapaoConfig.KillAura_RandomDelay = Options.RandomDelay.Value
        Config.RandomDelay = Options.RandomDelay.Value
    end)

    -- Status Button
    Tabs.Combat:AddButton({
        Title = "üìä System Status",
        Description = "Check current system status",
        Callback = function()
            local status = KillAura.Enabled and "üü¢ ACTIVE" or "üî¥ INACTIVE"
            local attackSpeed = "4 attacks/sec"
            
            Window:Dialog({
                Title = "Kill Aura Status",
                Content = "Kill Aura: " .. status .. 
                         "\nAttack Speed: " .. attackSpeed ..
                         "\nTargets Found: " .. #KillAura.TargetList ..
                         "\nRange: " .. Config.Range .. " studs" ..
                         "\nMax Targets: " .. Config.MaxTargets,
                Buttons = {
                    {
                        Title = "OK",
                        Callback = function()
                            -- Close dialog
                        end
                    }
                }
            })
        end
    })
end

-- Settings Tab Integration
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("KapaoHub")
SaveManager:SetFolder("KapaoHub/configs")

-- Add config info
Tabs.Settings:AddParagraph({
    Title = "üìÅ Configuration",
    Content = "Save and load your settings here"
})

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Add credits
Tabs.Settings:AddSection("Credits")
Tabs.Settings:AddParagraph({
    Title = "üëë Kapao Hub",
    Content = "Version: 1.0.1\nDeveloped with Coffee ;w;\n\nThank you for using Kapao Hub!"
})

-- Select first tab and show welcome notification
Window:SelectTab(1)

Fluent:Notify({
    Title = "‚òï Kapao Hub",
    Content = "Successfully loaded! Enjoy Coffee ;w;",
    SubContent = "Version 1.0.1",
    Duration = 8
})

-- Initialize Kill Aura System
KillAura:DetectAntiCheat()
